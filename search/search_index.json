{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pitaya-Link An Open-Source CMSIS-DAP Debug Probe based on DAPLink Description Pitaya-Link is a low-cost debug probe based on the CMSIS-DAP (also known as DAPLink ) protocol standard. It can be used to program and debug the application software running on Arm Cortex Microcontrollers. The design enables developers with Drag-And-Drop programming, Virtual COM Port, CMSIS-DAP compliant debug channel, and access to Arm Cortex Microcontrollers in the browser using WebUSB . The probe comes with indicator LEDs, a button to reset the target or trigger the firmware update, reversible USB-C connector and easy-to-use 7-pin 2.54mm Header. Features NXP Semiconductors LPC11U35FHI33 microcontroller 50 MHz Arm\u00ae Cortex-M0 processor 64kB flash 12kB SRAM ROM-based USB drivers. Flash updates via USB supported. Shipped with Arm Mbed DAPLink Firmware MSC - drag-n-drop programming flash memory CDC - virtual com port for log, trace and terminal emulation HID - CMSIS-DAP compliant debug channel WEBUSB HID - CMSIS-DAP compliant debug channel Supported by various IDEs and applications: pyOCD , DAP.js , VS Code , KEIL , IAR etc. RGB LED indicator Button 3.3V DC-DC regulator with 1A output current 3.3V Digital I/O Operating Voltage Reversible USB-C Connector Easy-to-use 7-pin 2.54mm Header with SWD UART interface Very small form factor: 25 x 40 mm Hardware Diagram Included in the Box Part Qty Pitaya-Link Board 1 7-pin Female/Male Cable 1 7-pin Female/Female Cable 1 USB-C Cable 1 Tutorials In order to help you use Pitaya-Link in your development environment, we have provided a series of tutorials. Find the details below: Getting Started with Pitaya-Link Using Pitaya-Link with pyOCD Using Pitaya-Link with DAP.js Using Pitaya-Link with Visual Studio Code Using Pitaya-Link with GNU MCU Eclipse Using Pitaya-Link with ARM KEIL MDK Using Pitaya-Link with IAR Embedded Workbench Upgrading the DAPLink Firmware Building your own DAPLink Firmware Design Files Pitaya-Link Hardware Diagram V1.0 Pitaya-Link Schematic V1.0 Pitaya-Link Board File V1.0 Pitaya-Link 3D STEP V1.0 Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Introduction"},{"location":"#pitaya-link-an-open-source-cmsis-dap-debug-probe-based-on-daplink","text":"","title":"Pitaya-Link An Open-Source CMSIS-DAP Debug Probe based on DAPLink"},{"location":"#description","text":"Pitaya-Link is a low-cost debug probe based on the CMSIS-DAP (also known as DAPLink ) protocol standard. It can be used to program and debug the application software running on Arm Cortex Microcontrollers. The design enables developers with Drag-And-Drop programming, Virtual COM Port, CMSIS-DAP compliant debug channel, and access to Arm Cortex Microcontrollers in the browser using WebUSB . The probe comes with indicator LEDs, a button to reset the target or trigger the firmware update, reversible USB-C connector and easy-to-use 7-pin 2.54mm Header.","title":"Description"},{"location":"#features","text":"NXP Semiconductors LPC11U35FHI33 microcontroller 50 MHz Arm\u00ae Cortex-M0 processor 64kB flash 12kB SRAM ROM-based USB drivers. Flash updates via USB supported. Shipped with Arm Mbed DAPLink Firmware MSC - drag-n-drop programming flash memory CDC - virtual com port for log, trace and terminal emulation HID - CMSIS-DAP compliant debug channel WEBUSB HID - CMSIS-DAP compliant debug channel Supported by various IDEs and applications: pyOCD , DAP.js , VS Code , KEIL , IAR etc. RGB LED indicator Button 3.3V DC-DC regulator with 1A output current 3.3V Digital I/O Operating Voltage Reversible USB-C Connector Easy-to-use 7-pin 2.54mm Header with SWD UART interface Very small form factor: 25 x 40 mm","title":"Features"},{"location":"#hardware-diagram","text":"","title":"Hardware Diagram"},{"location":"#included-in-the-box","text":"Part Qty Pitaya-Link Board 1 7-pin Female/Male Cable 1 7-pin Female/Female Cable 1 USB-C Cable 1","title":"Included in the Box"},{"location":"#tutorials","text":"In order to help you use Pitaya-Link in your development environment, we have provided a series of tutorials. Find the details below: Getting Started with Pitaya-Link Using Pitaya-Link with pyOCD Using Pitaya-Link with DAP.js Using Pitaya-Link with Visual Studio Code Using Pitaya-Link with GNU MCU Eclipse Using Pitaya-Link with ARM KEIL MDK Using Pitaya-Link with IAR Embedded Workbench Upgrading the DAPLink Firmware Building your own DAPLink Firmware","title":"Tutorials"},{"location":"#design-files","text":"Pitaya-Link Hardware Diagram V1.0 Pitaya-Link Schematic V1.0 Pitaya-Link Board File V1.0 Pitaya-Link 3D STEP V1.0","title":"Design Files"},{"location":"#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"CONTRIBUTING/","text":"Contributing Interested in contributing to Pitaya-Link ? Want to report a bug? Before you do, please read the following guidelines. Got a question or problem? For quick questions there's no need to open an issue as you can reach us on makerdiary/community . Found a bug? If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. Requesting a tutorial If you don't see what you're looking for, you can request a tutoial by submitting an issue to our GitHub Repository. We'd love to see your feedback! Request a tutoial","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Interested in contributing to Pitaya-Link ? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"CONTRIBUTING/#got-a-question-or-problem","text":"For quick questions there's no need to open an issue as you can reach us on makerdiary/community .","title":"Got a question or problem?"},{"location":"CONTRIBUTING/#found-a-bug","text":"If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix.","title":"Found a bug?"},{"location":"CONTRIBUTING/#requesting-a-tutorial","text":"If you don't see what you're looking for, you can request a tutoial by submitting an issue to our GitHub Repository. We'd love to see your feedback! Request a tutoial","title":"Requesting a tutorial"},{"location":"LICENSE/","text":"MIT License Copyright 2020 makerdiary Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"building/","text":"Building your own DAPLink firmware Introduction Arm Mbed DAPLink is an open-source software project that enables programming and debugging application software running on Arm Cortex CPUs. More features are planned and will show up gradually over time. The project is constantly under heavy development by Arm, its partners, numerous hardware vendors and the open-source community around the world. You are free to use and contribute. Enjoy! For more detailed information, please refer to DAPLink GitHub repository . This section describes how to set up a development environment and create a release build. Note The following instructions only work on Windows computer. Set up prerequisites Install the necessary tools listed below. Skip any step where a compatible tool already exists. Install Python 2, 2.7.11 or above . Add to PATH. Install Git . Add to PATH. Install Keil MDK-ARM , preferably version 5. Note Set environment variable UV4 to the absolute path of the UV4 executable if you don't install to the default location. Note that UV4 is what's used for both MDK versions 4 and 5. Install virtualenv in your global Python installation eg: pip install virtualenv . Clone the sources Get the sources and create a virtual environment: $ git clone https://github.com/makerdiary/DAPLink $ cd DAPLink $ pip install virtualenv $ virtualenv venv Activate virtual environment Activate the virtual environment and update requirements. This is necessary when you open a new shell. $ venv/Scripts/activate ( For Linux ) $ venv/Scripts/activate.bat ( For Windows ) $ pip install -r requirements.txt Generate MDK project files Generate the Pitaya-Link project by running the following command: progen generate -f projects.yaml -p lpc11u35_pitaya_link_if -t uvision The project files are located in the projectfiles/uvision directory. Note This step MUST be done every time you pull new changes! Build the project Change to the projectfiles/uvision/lpc11u35_pitaya_link_if directory, and open the project using Keil MDK-ARM. Click the build icon to build the project. The new fimware is located in the lpc11u35_pitaya_link_if/build directory with the name lpc11u35_pitaya_link_if_crc.bin . Follow the Upgrading Firmware section to upgrade. Reference DAPLink Developers Guide Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Building DAPLink"},{"location":"building/#building-your-own-daplink-firmware","text":"","title":"Building your own DAPLink firmware"},{"location":"building/#introduction","text":"Arm Mbed DAPLink is an open-source software project that enables programming and debugging application software running on Arm Cortex CPUs. More features are planned and will show up gradually over time. The project is constantly under heavy development by Arm, its partners, numerous hardware vendors and the open-source community around the world. You are free to use and contribute. Enjoy! For more detailed information, please refer to DAPLink GitHub repository . This section describes how to set up a development environment and create a release build. Note The following instructions only work on Windows computer.","title":"Introduction"},{"location":"building/#set-up-prerequisites","text":"Install the necessary tools listed below. Skip any step where a compatible tool already exists. Install Python 2, 2.7.11 or above . Add to PATH. Install Git . Add to PATH. Install Keil MDK-ARM , preferably version 5. Note Set environment variable UV4 to the absolute path of the UV4 executable if you don't install to the default location. Note that UV4 is what's used for both MDK versions 4 and 5. Install virtualenv in your global Python installation eg: pip install virtualenv .","title":"Set up prerequisites"},{"location":"building/#clone-the-sources","text":"Get the sources and create a virtual environment: $ git clone https://github.com/makerdiary/DAPLink $ cd DAPLink $ pip install virtualenv $ virtualenv venv","title":"Clone the sources"},{"location":"building/#activate-virtual-environment","text":"Activate the virtual environment and update requirements. This is necessary when you open a new shell. $ venv/Scripts/activate ( For Linux ) $ venv/Scripts/activate.bat ( For Windows ) $ pip install -r requirements.txt","title":"Activate virtual environment"},{"location":"building/#generate-mdk-project-files","text":"Generate the Pitaya-Link project by running the following command: progen generate -f projects.yaml -p lpc11u35_pitaya_link_if -t uvision The project files are located in the projectfiles/uvision directory. Note This step MUST be done every time you pull new changes!","title":"Generate MDK project files"},{"location":"building/#build-the-project","text":"Change to the projectfiles/uvision/lpc11u35_pitaya_link_if directory, and open the project using Keil MDK-ARM. Click the build icon to build the project. The new fimware is located in the lpc11u35_pitaya_link_if/build directory with the name lpc11u35_pitaya_link_if_crc.bin . Follow the Upgrading Firmware section to upgrade.","title":"Build the project"},{"location":"building/#reference","text":"DAPLink Developers Guide","title":"Reference"},{"location":"building/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"dapjs/","text":"Using Pitaya-Link with DAP.js Introduction DAP.js is a JavaScript interface to CMSIS-DAP , enabling access to Arm Microcontrollers using Node.js or in the browser using WebUSB . This page demonstrates the flash exmaple using DAP.js. Refer to the DAP.js API Documentation for more information. Drag and drop a firmware image here Select Device let dropEl = document.getElementById(\"drop\"); let fileEl = document.getElementById(\"file\"); let selectEl = document.getElementById(\"select\"); let buttonEl = document.getElementById(\"button\"); let labelEl = document.getElementById(\"label\"); let statusEl = document.getElementById(\"status\"); let transferEl = document.getElementById(\"transfer\"); let barEl = document.getElementById(\"bar\"); let buffer = null; function setStatus(state) { labelEl.textContent = state; } function setTransfer(progress) { if (!progress) { statusEl.style.visibility = \"hidden\"; return; } selectEl.style.visibility = \"hidden\"; statusEl.style.visibility = \"visible\"; barEl.style.width = `${progress * 100}%`; transferEl.textContent = `${Math.ceil(progress * 100)}%`; } // Load a firmware image function setImage(file) { if (!file) return; const reader = new FileReader(); reader.onloadend = function(evt) { buffer = evt.target.result; setStatus(`Firmware image: ${file.name}`); selectEl.style.visibility = \"visible\"; } reader.readAsArrayBuffer(file); } // Choose a device function selectDevice() { setStatus(\"Selecting device...\"); setTransfer(); navigator.usb.requestDevice({ filters: [{vendorId: 0xD28}] }) .then(device => update(device)) .catch(error => { statusEl.style.visibility = \"hidden\"; setStatus(error); }); } // Update a device with the firmware image function update(device) { if (!buffer) return; const transport = new DAPjs.WebUSB(device); const target = new DAPjs.DAPLink(transport); target.on(DAPjs.DAPLink.EVENT_PROGRESS, progress => { setTransfer(progress); }); // Push binary to board return target.connect() .then(() => { setStatus(`Flashing binary file ${buffer.byteLength} words long...`); return target.flash(buffer); }) .then(() => { setStatus(\"Disconnecting...\"); return target.disconnect(); }) .then(() => { setStatus(\"Flash complete!\"); setTransfer(); fileEl.value = \"\"; }) .catch(error => { statusEl.style.visibility = \"hidden\"; setStatus(error); }); } fileEl.addEventListener(\"change\", event => { setImage(event.target.files[0]); }); dropEl.addEventListener(\"drop\", event => { setImage(event.dataTransfer.files[0]); }); buttonEl.addEventListener(\"click\", selectDevice); [\"drag\", \"dragstart\", \"dragend\", \"dragover\", \"dragenter\", \"dragleave\", \"drop\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { event.preventDefault(); event.stopPropagation(); }); }); [\"dragover\", \"dragenter\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { dropEl.classList.add(\"hover\"); }); }); [\"dragleave\", \"dragend\", \"drop\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { dropEl.classList.remove(\"hover\"); }); }); Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with DAP.js"},{"location":"dapjs/#using-pitaya-link-with-dapjs","text":"","title":"Using Pitaya-Link with DAP.js"},{"location":"dapjs/#introduction","text":"DAP.js is a JavaScript interface to CMSIS-DAP , enabling access to Arm Microcontrollers using Node.js or in the browser using WebUSB . This page demonstrates the flash exmaple using DAP.js. Refer to the DAP.js API Documentation for more information. Drag and drop a firmware image here Select Device let dropEl = document.getElementById(\"drop\"); let fileEl = document.getElementById(\"file\"); let selectEl = document.getElementById(\"select\"); let buttonEl = document.getElementById(\"button\"); let labelEl = document.getElementById(\"label\"); let statusEl = document.getElementById(\"status\"); let transferEl = document.getElementById(\"transfer\"); let barEl = document.getElementById(\"bar\"); let buffer = null; function setStatus(state) { labelEl.textContent = state; } function setTransfer(progress) { if (!progress) { statusEl.style.visibility = \"hidden\"; return; } selectEl.style.visibility = \"hidden\"; statusEl.style.visibility = \"visible\"; barEl.style.width = `${progress * 100}%`; transferEl.textContent = `${Math.ceil(progress * 100)}%`; } // Load a firmware image function setImage(file) { if (!file) return; const reader = new FileReader(); reader.onloadend = function(evt) { buffer = evt.target.result; setStatus(`Firmware image: ${file.name}`); selectEl.style.visibility = \"visible\"; } reader.readAsArrayBuffer(file); } // Choose a device function selectDevice() { setStatus(\"Selecting device...\"); setTransfer(); navigator.usb.requestDevice({ filters: [{vendorId: 0xD28}] }) .then(device => update(device)) .catch(error => { statusEl.style.visibility = \"hidden\"; setStatus(error); }); } // Update a device with the firmware image function update(device) { if (!buffer) return; const transport = new DAPjs.WebUSB(device); const target = new DAPjs.DAPLink(transport); target.on(DAPjs.DAPLink.EVENT_PROGRESS, progress => { setTransfer(progress); }); // Push binary to board return target.connect() .then(() => { setStatus(`Flashing binary file ${buffer.byteLength} words long...`); return target.flash(buffer); }) .then(() => { setStatus(\"Disconnecting...\"); return target.disconnect(); }) .then(() => { setStatus(\"Flash complete!\"); setTransfer(); fileEl.value = \"\"; }) .catch(error => { statusEl.style.visibility = \"hidden\"; setStatus(error); }); } fileEl.addEventListener(\"change\", event => { setImage(event.target.files[0]); }); dropEl.addEventListener(\"drop\", event => { setImage(event.dataTransfer.files[0]); }); buttonEl.addEventListener(\"click\", selectDevice); [\"drag\", \"dragstart\", \"dragend\", \"dragover\", \"dragenter\", \"dragleave\", \"drop\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { event.preventDefault(); event.stopPropagation(); }); }); [\"dragover\", \"dragenter\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { dropEl.classList.add(\"hover\"); }); }); [\"dragleave\", \"dragend\", \"drop\"].forEach(eventName => { dropEl.addEventListener(eventName, event => { dropEl.classList.remove(\"hover\"); }); });","title":"Introduction"},{"location":"dapjs/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"eclipse/","text":"Using Pitaya-Link with GNU MCU Eclipse Introduction GNU MCU Eclipse fully supports pyOCD with an included pyOCD debugging plugin. This guide explains how to configure the local debug toolchain using Pitaya-Link with GNU MCU Eclipse. Requirements A Pitaya-Link Debug Probe Eclipse IDE for C/C++ Developers An nRF52 target board (e.g. nRF52840 MDK USB Dongle ) Installing Eclipse You need to install Eclipse CDT with the GNU MCU Eclipse plugins to begin: Install Eclipse IDE for C/C++ Developers . Open Eclipse. Create a workspace directory. This will be separate from your code. Install the GNU MCU Eclipse plugin: Click the Help menu item and select Eclipse Marketplace\u2026 Find GNU MCU Eclipse and install. Select GNU MCU Eclipse x.x.x and confirm. Install pyOCD The latest stable version of pyOCD may be installed via pip as follows. Skip this step if pyOCD already exists. pip install -U pyocd Install GNU Arm Embedded Toolchain Download and install the GNU ARM Embedded Toolchain . Skip this step if the toolchain already exists. Importing the project in Eclipse Open Eclipse. On the Welcome window , select Import a project with a working Makefile . Select the folder to your project with a Makefile. E.g., blinky/armgcc . Under Toolchain for Indexer Settings , select Cross ARM GCC . Click Finish . Configuring the debugger Select Run Debug Configurations... . If no configuration exists under GDB pyOCD Debugging , click on New launch configuration . In the Main tab, select the .out file ( _build/nrf52840_xxaa.out ) under C/C++ Application . In the Debugger tab: Under pyOCD Setup , set the Executable path and make sure that it is pointing to your latest version of the pyocd-gdbserver . Under GDB Client Setup , set the Executable path to your arm-none-eabi-gdb . Click Apply . Tip The which (on macOS/Linux) or where (on Windows) shell command can be used to find the location of pyocd-gdbserver and arm-none-eabi-gdb . E.g., which pyocd-gdbserver and which arm-none-eabi-gdb . Connecting the target Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. Debugging your project Click the menu Run - Debug , and debugging starts. Click on the Debugger Console tab to see the debug output: Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with GNU MCU Eclipse"},{"location":"eclipse/#using-pitaya-link-with-gnu-mcu-eclipse","text":"","title":"Using Pitaya-Link with GNU MCU Eclipse"},{"location":"eclipse/#introduction","text":"GNU MCU Eclipse fully supports pyOCD with an included pyOCD debugging plugin. This guide explains how to configure the local debug toolchain using Pitaya-Link with GNU MCU Eclipse.","title":"Introduction"},{"location":"eclipse/#requirements","text":"A Pitaya-Link Debug Probe Eclipse IDE for C/C++ Developers An nRF52 target board (e.g. nRF52840 MDK USB Dongle )","title":"Requirements"},{"location":"eclipse/#installing-eclipse","text":"You need to install Eclipse CDT with the GNU MCU Eclipse plugins to begin: Install Eclipse IDE for C/C++ Developers . Open Eclipse. Create a workspace directory. This will be separate from your code. Install the GNU MCU Eclipse plugin: Click the Help menu item and select Eclipse Marketplace\u2026 Find GNU MCU Eclipse and install. Select GNU MCU Eclipse x.x.x and confirm.","title":"Installing Eclipse"},{"location":"eclipse/#install-pyocd","text":"The latest stable version of pyOCD may be installed via pip as follows. Skip this step if pyOCD already exists. pip install -U pyocd","title":"Install pyOCD"},{"location":"eclipse/#install-gnu-arm-embedded-toolchain","text":"Download and install the GNU ARM Embedded Toolchain . Skip this step if the toolchain already exists.","title":"Install GNU Arm Embedded Toolchain"},{"location":"eclipse/#importing-the-project-in-eclipse","text":"Open Eclipse. On the Welcome window , select Import a project with a working Makefile . Select the folder to your project with a Makefile. E.g., blinky/armgcc . Under Toolchain for Indexer Settings , select Cross ARM GCC . Click Finish .","title":"Importing the project in Eclipse"},{"location":"eclipse/#configuring-the-debugger","text":"Select Run Debug Configurations... . If no configuration exists under GDB pyOCD Debugging , click on New launch configuration . In the Main tab, select the .out file ( _build/nrf52840_xxaa.out ) under C/C++ Application . In the Debugger tab: Under pyOCD Setup , set the Executable path and make sure that it is pointing to your latest version of the pyocd-gdbserver . Under GDB Client Setup , set the Executable path to your arm-none-eabi-gdb . Click Apply . Tip The which (on macOS/Linux) or where (on Windows) shell command can be used to find the location of pyocd-gdbserver and arm-none-eabi-gdb . E.g., which pyocd-gdbserver and which arm-none-eabi-gdb .","title":"Configuring the debugger"},{"location":"eclipse/#connecting-the-target","text":"Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable.","title":"Connecting the target"},{"location":"eclipse/#debugging-your-project","text":"Click the menu Run - Debug , and debugging starts. Click on the Debugger Console tab to see the debug output:","title":"Debugging your project"},{"location":"eclipse/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"getting-started/","text":"Getting Started Out of the Box Introduction This guide is intended to assist users in the initial setup and demonstration of the basic usage with Pitaya-Link: Logging via Serial port Drag-and-drop programming Programming via pyOCD What you'll need A Pitaya-Link Debug Probe A macOS/Linux/Windows PC An nRF52 target board(e.g. nRF52840 MDK USB Dongle ) Connect the target Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. A disk drive called PITAYA-LINK will be automatically detected by the computer. Logging via Serial port Pitaya-Link enables developers with a Virtual COM Port which you can use for logging and reporting application state. There are many Terminal applications available for your host PC. They provide a window where your target can print messages. Select the tool according to your host: screen (for macOS/Linux) PuTTY (for Windows) CoolTerm (for macOS/Linux/Windows) Drag-and-drop programming Drag-And-Drop is an optional intuitive programming feature. It allows programming of your target MCU in a very simple way: dragging and dropping a file ( .hex -format) onto the PITAYA-LINK drive. There is no need to install application software. Anyone that can drag and drop a file to a USB memory stick can now program the target board. Tip Upon completion, the drive remounts. If a failure occurs, the file FAIL.TXT appears on the drive containing information about the failure. Programming via pyOCD pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows. The latest stable version of pyOCD can be installed via pip as follows: pip install -U pyocd Here is an example command showing how to flash an nRF52840-based target: pyocd flash -t nrf52840 Sample.hex Tip For more instructions about using pyOCD, see Usage with pyOCD section. Explore Further Now that you are familiar with the Pitaya-Link, it's time to explore more tutorials available below: Using Pitaya-Link with pyOCD Using Pitaya-Link with DAP.js Using Pitaya-Link with Visual Studio Code Using Pitaya-Link with GNU MCU Eclipse Using Pitaya-Link with KEIL \u00b5Vision IDE Using Pitaya-Link with IAR Embedded Workbench Upgrading the DAPLink Firmware Building your own DAPLink Firmware Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Getting Started"},{"location":"getting-started/#getting-started-out-of-the-box","text":"","title":"Getting Started Out of the Box"},{"location":"getting-started/#introduction","text":"This guide is intended to assist users in the initial setup and demonstration of the basic usage with Pitaya-Link: Logging via Serial port Drag-and-drop programming Programming via pyOCD","title":"Introduction"},{"location":"getting-started/#what-youll-need","text":"A Pitaya-Link Debug Probe A macOS/Linux/Windows PC An nRF52 target board(e.g. nRF52840 MDK USB Dongle )","title":"What you'll need"},{"location":"getting-started/#connect-the-target","text":"Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. A disk drive called PITAYA-LINK will be automatically detected by the computer.","title":"Connect the target"},{"location":"getting-started/#logging-via-serial-port","text":"Pitaya-Link enables developers with a Virtual COM Port which you can use for logging and reporting application state. There are many Terminal applications available for your host PC. They provide a window where your target can print messages. Select the tool according to your host: screen (for macOS/Linux) PuTTY (for Windows) CoolTerm (for macOS/Linux/Windows)","title":"Logging via Serial port"},{"location":"getting-started/#drag-and-drop-programming","text":"Drag-And-Drop is an optional intuitive programming feature. It allows programming of your target MCU in a very simple way: dragging and dropping a file ( .hex -format) onto the PITAYA-LINK drive. There is no need to install application software. Anyone that can drag and drop a file to a USB memory stick can now program the target board. Tip Upon completion, the drive remounts. If a failure occurs, the file FAIL.TXT appears on the drive containing information about the failure.","title":"Drag-and-drop programming"},{"location":"getting-started/#programming-via-pyocd","text":"pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows. The latest stable version of pyOCD can be installed via pip as follows: pip install -U pyocd Here is an example command showing how to flash an nRF52840-based target: pyocd flash -t nrf52840 Sample.hex Tip For more instructions about using pyOCD, see Usage with pyOCD section.","title":"Programming via pyOCD"},{"location":"getting-started/#explore-further","text":"Now that you are familiar with the Pitaya-Link, it's time to explore more tutorials available below: Using Pitaya-Link with pyOCD Using Pitaya-Link with DAP.js Using Pitaya-Link with Visual Studio Code Using Pitaya-Link with GNU MCU Eclipse Using Pitaya-Link with KEIL \u00b5Vision IDE Using Pitaya-Link with IAR Embedded Workbench Upgrading the DAPLink Firmware Building your own DAPLink Firmware","title":"Explore Further"},{"location":"getting-started/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"iar-ewarm/","text":"Using Pitaya-Link with IAR Embedded Workbench Introduction IAR's EWARM is a completely integrated development environment that supports CMSIS-DAP out-of-the-box. This guide explains how to configure the local debug toolchain using Pitaya-Link with IAR's EWARM. Requirements A Pitaya-Link Debug Probe IAR Embedded Workbench for ARM An nRF52 target board (e.g. nRF52840 MDK USB Dongle ) Connecting the target Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. Configuring the debugger Open your IAR project. Click Options from the Project menu. In the option window, select Debugger from the menu on the left. In the Setup tab, select CMSIS DAP from the Driver drop-down menu. In the Download tab, check Verify download and Use flash loader(s) . Make sure that the correct .board file is used. Select CMSIS DAP from the menu on the left, select the Interface tab and configure the SWD protocol. Click OK to save the options. Debugging your project Insert a Breakpoint in your code. Click the menu Project - Download and Debug , and debugging starts. Now you can explore IAR's debugging capabilities. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with IAR Workbench"},{"location":"iar-ewarm/#using-pitaya-link-with-iar-embedded-workbench","text":"","title":"Using Pitaya-Link with IAR Embedded Workbench"},{"location":"iar-ewarm/#introduction","text":"IAR's EWARM is a completely integrated development environment that supports CMSIS-DAP out-of-the-box. This guide explains how to configure the local debug toolchain using Pitaya-Link with IAR's EWARM.","title":"Introduction"},{"location":"iar-ewarm/#requirements","text":"A Pitaya-Link Debug Probe IAR Embedded Workbench for ARM An nRF52 target board (e.g. nRF52840 MDK USB Dongle )","title":"Requirements"},{"location":"iar-ewarm/#connecting-the-target","text":"Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable.","title":"Connecting the target"},{"location":"iar-ewarm/#configuring-the-debugger","text":"Open your IAR project. Click Options from the Project menu. In the option window, select Debugger from the menu on the left. In the Setup tab, select CMSIS DAP from the Driver drop-down menu. In the Download tab, check Verify download and Use flash loader(s) . Make sure that the correct .board file is used. Select CMSIS DAP from the menu on the left, select the Interface tab and configure the SWD protocol. Click OK to save the options.","title":"Configuring the debugger"},{"location":"iar-ewarm/#debugging-your-project","text":"Insert a Breakpoint in your code. Click the menu Project - Download and Debug , and debugging starts. Now you can explore IAR's debugging capabilities.","title":"Debugging your project"},{"location":"iar-ewarm/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"keil-mdk/","text":"Using Pitaya-Link with ARM KEIL MDK Introduction Keil MDK is the complete software development environment for a wide range of Arm Cortex-M based microcontroller devices. MDK includes the \u00b5Vision IDE and debugger, Arm C/C++ compiler, and essential middleware components. It supports all silicon vendors with more than 6,000 devices and is easy to learn and use. This guide explains how to configure the local debug toolchain using Pitaya-Link with ARM KEIL MDK. Note Due to the linker limits, this does not work in the free version of uVision. If you do not have a uVision license, you can use Eclipse or Visual Studio Code instead. Requirements A Pitaya-Link Debug Probe ARM Keil MDK An nRF52 target board (e.g. nRF52840 MDK USB Dongle ) Connecting the target Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. Configuring the debugger Open your Keil MDK project. Go to Project - Options for Target - Debug , and select CMSIS-DAP Debugger from the drop-down menu. Click Settings button. In the next windows select the DAPLink CMSIS-DAP adapter. Set the SW mode. In the SW Device , you can view the target device. Click OK to save the options. Debugging your project Insert a Breakpoint in your code. Click the menu Debug - Start/Stop Debug Session , and debugging starts. Now you can explore the debugging capabilities for Variables, Registers and more. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with ARM KEIL MDK"},{"location":"keil-mdk/#using-pitaya-link-with-arm-keil-mdk","text":"","title":"Using Pitaya-Link with ARM KEIL MDK"},{"location":"keil-mdk/#introduction","text":"Keil MDK is the complete software development environment for a wide range of Arm Cortex-M based microcontroller devices. MDK includes the \u00b5Vision IDE and debugger, Arm C/C++ compiler, and essential middleware components. It supports all silicon vendors with more than 6,000 devices and is easy to learn and use. This guide explains how to configure the local debug toolchain using Pitaya-Link with ARM KEIL MDK. Note Due to the linker limits, this does not work in the free version of uVision. If you do not have a uVision license, you can use Eclipse or Visual Studio Code instead.","title":"Introduction"},{"location":"keil-mdk/#requirements","text":"A Pitaya-Link Debug Probe ARM Keil MDK An nRF52 target board (e.g. nRF52840 MDK USB Dongle )","title":"Requirements"},{"location":"keil-mdk/#connecting-the-target","text":"Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable.","title":"Connecting the target"},{"location":"keil-mdk/#configuring-the-debugger","text":"Open your Keil MDK project. Go to Project - Options for Target - Debug , and select CMSIS-DAP Debugger from the drop-down menu. Click Settings button. In the next windows select the DAPLink CMSIS-DAP adapter. Set the SW mode. In the SW Device , you can view the target device. Click OK to save the options.","title":"Configuring the debugger"},{"location":"keil-mdk/#debugging-your-project","text":"Insert a Breakpoint in your code. Click the menu Debug - Start/Stop Debug Session , and debugging starts. Now you can explore the debugging capabilities for Variables, Registers and more.","title":"Debugging your project"},{"location":"keil-mdk/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"pyocd/","text":"Using Pitaya-Link with pyOCD Overview pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows. A command line tool is provided that covers most use cases, or you can make use of the Python API to enable low-level target control. A common use for the Python API is to run and control CI tests. Upwards of 70 popular MCUs are supported built-in. In addition, through the use of CMSIS-Packs, nearly every Cortex-M device on the market is supported. This guide demonstrates the basic usage of pyOCD with Pitaya-Link. For more detailed information, refer to the pyOCD GitHub repository . What you'll need A Pitaya-Link Debug Probe A macOS/Linux/Windows PC An nRF52 target board(e.g. nRF52840 MDK USB Dongle ) Installing The latest stable version of pyOCD may be installed via pip as follows: pip install -U pyocd Alternatively, to install the latest prerelease version from the HEAD of the master branch, you can do the following: pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip Basic Usage The pyocd command line tool gives you total control over your target with these subcommands: gdbserver : GDB remote server allows you to debug using gdb via either GNU MCU Eclipse plug-in or the console. flash : Program files of various formats into flash memory. erase : Erase part or all of an MCU's flash memory. pack : Manage CMSIS Device Family Packs that provide additional target device support. commander : Interactive REPL control and inspection of the MCU. list : Show connected devices. Target support When pyOCD connects to a target, it needs to know what type of target it is controlling. To see the available target types you can run: pyocd list --targets Programming The flash programming may be the most frequently used option of Pitya-Link. pyOCD offers a variety of commands for programming with different options. You can get additional help by running: pyocd erase --help pyocd flash --help The following commands demonstrate how to flash/erase an nRF52840-based target: To erase all of the target flash: pyocd erase -t nrf52840 --chip To flash the target with .hex -format firmware: pyocd flash -t nrf52840 Sample.hex To flash the target with a plain binary: pyocd flash -t nrf52840 --base-address 0x1000 Sample.bin Note The --base-address option is used for setting the address where to flash a binary. Defaults to start of flash. Debugging pyOCD contains a GDB remote server which allows you to debug using gdb. You can get additional help by running: pyocd gdbserver --help . You will be able to execute the following in order to start a GDB server: pyocd gdbserver -t nrf52840 In the second terminal window, connect to the GDB server and load firmware by running: $ arm-none-eabi-gdb application.elf gdb target remote localhost:3333 gdb load gdb monitor reset The GDB server also works well with Eclipse and the GNU MCU Eclipse plug-ins . GNU MCU Eclipse fully supports pyOCD with an included pyOCD debugging plugin. For instructions on GNU MCU Eclipse for pyOCD, please refer to: Using Pitaya-Link with GNU MCU Eclipse Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with pyOCD"},{"location":"pyocd/#using-pitaya-link-with-pyocd","text":"","title":"Using Pitaya-Link with pyOCD"},{"location":"pyocd/#overview","text":"pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows. A command line tool is provided that covers most use cases, or you can make use of the Python API to enable low-level target control. A common use for the Python API is to run and control CI tests. Upwards of 70 popular MCUs are supported built-in. In addition, through the use of CMSIS-Packs, nearly every Cortex-M device on the market is supported. This guide demonstrates the basic usage of pyOCD with Pitaya-Link. For more detailed information, refer to the pyOCD GitHub repository .","title":"Overview"},{"location":"pyocd/#what-youll-need","text":"A Pitaya-Link Debug Probe A macOS/Linux/Windows PC An nRF52 target board(e.g. nRF52840 MDK USB Dongle )","title":"What you'll need"},{"location":"pyocd/#installing","text":"The latest stable version of pyOCD may be installed via pip as follows: pip install -U pyocd Alternatively, to install the latest prerelease version from the HEAD of the master branch, you can do the following: pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip","title":"Installing"},{"location":"pyocd/#basic-usage","text":"The pyocd command line tool gives you total control over your target with these subcommands: gdbserver : GDB remote server allows you to debug using gdb via either GNU MCU Eclipse plug-in or the console. flash : Program files of various formats into flash memory. erase : Erase part or all of an MCU's flash memory. pack : Manage CMSIS Device Family Packs that provide additional target device support. commander : Interactive REPL control and inspection of the MCU. list : Show connected devices.","title":"Basic Usage"},{"location":"pyocd/#target-support","text":"When pyOCD connects to a target, it needs to know what type of target it is controlling. To see the available target types you can run: pyocd list --targets","title":"Target support"},{"location":"pyocd/#programming","text":"The flash programming may be the most frequently used option of Pitya-Link. pyOCD offers a variety of commands for programming with different options. You can get additional help by running: pyocd erase --help pyocd flash --help The following commands demonstrate how to flash/erase an nRF52840-based target: To erase all of the target flash: pyocd erase -t nrf52840 --chip To flash the target with .hex -format firmware: pyocd flash -t nrf52840 Sample.hex To flash the target with a plain binary: pyocd flash -t nrf52840 --base-address 0x1000 Sample.bin Note The --base-address option is used for setting the address where to flash a binary. Defaults to start of flash.","title":"Programming"},{"location":"pyocd/#debugging","text":"pyOCD contains a GDB remote server which allows you to debug using gdb. You can get additional help by running: pyocd gdbserver --help . You will be able to execute the following in order to start a GDB server: pyocd gdbserver -t nrf52840 In the second terminal window, connect to the GDB server and load firmware by running: $ arm-none-eabi-gdb application.elf gdb target remote localhost:3333 gdb load gdb monitor reset The GDB server also works well with Eclipse and the GNU MCU Eclipse plug-ins . GNU MCU Eclipse fully supports pyOCD with an included pyOCD debugging plugin. For instructions on GNU MCU Eclipse for pyOCD, please refer to: Using Pitaya-Link with GNU MCU Eclipse","title":"Debugging"},{"location":"pyocd/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"supported-targets/","text":"Supported Targets Using pyOCD Through both built-in support and CMSIS-Packs, pyOCD supports nearly every Cortex-M MCU that is available on the market. To see the available target types you can run the following command: pyocd list --targets Drag-and-drop programming targets A flash algorithm blob is needed to program the target MCU while programming an image across the Drag-and-drop channel. This blob contains position independent functions for erasing, reading and writing to the flash controller. The following table shows the targets that support Drag-and-drop programming. More targets are planned and will show up gradually over time. Target Firmware nRF52 SoC (Default) pitaya_link_nrf52_if_crc_xxxx.bin Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Supported Targets"},{"location":"supported-targets/#supported-targets","text":"","title":"Supported Targets"},{"location":"supported-targets/#using-pyocd","text":"Through both built-in support and CMSIS-Packs, pyOCD supports nearly every Cortex-M MCU that is available on the market. To see the available target types you can run the following command: pyocd list --targets","title":"Using pyOCD"},{"location":"supported-targets/#drag-and-drop-programming-targets","text":"A flash algorithm blob is needed to program the target MCU while programming an image across the Drag-and-drop channel. This blob contains position independent functions for erasing, reading and writing to the flash controller. The following table shows the targets that support Drag-and-drop programming. More targets are planned and will show up gradually over time. Target Firmware nRF52 SoC (Default) pitaya_link_nrf52_if_crc_xxxx.bin","title":"Drag-and-drop programming targets"},{"location":"supported-targets/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"upgrading/","text":"Upgrading the DAPLink Firmware Introduction Pitaya-Link can be easily upgraded via the on-chip bootloader software over USB. An update ensures you have the most recent features and improvements for your current version of DAPLink firmware. This section describes how to upgrade to the latest DAPLink firmware. Requirements A Pitaya-Link Debug Probe macOS, Linux, or Windows 7 or newer 1x USB-C Cable Prepare the firmware The current release DAPLink firmware is hosted on GitHub Release Site with the name pitaya_link_ target _if_crc_ version .bin . Download Update the firmware To update the firmware, follow these steps: Enter DFU mode by pressing DFU/RESET button during power up. The board should mount as a disk drive called CRP DISABLD . Open CRP DISABLD , and remove the file called firmware.bin . Copy the new firmware ( .bin -format file prepared above) onto CRP DISABLD : On Windows, replace firmware.bin with the new firmware. On Linux/macOS, use dd command: dd if ={ new_firmware.bin } of ={ firmware.bin } conv = notrunc Unplug your Pitaya-Link, and plug it back in. It should now appear as a disk drive called PITAYA-LINK . Verify the update Check the DETAILS.TXT file in PITAYA-LINK to verify the Interface Version . Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Upgrading Firmware"},{"location":"upgrading/#upgrading-the-daplink-firmware","text":"","title":"Upgrading the DAPLink Firmware"},{"location":"upgrading/#introduction","text":"Pitaya-Link can be easily upgraded via the on-chip bootloader software over USB. An update ensures you have the most recent features and improvements for your current version of DAPLink firmware. This section describes how to upgrade to the latest DAPLink firmware.","title":"Introduction"},{"location":"upgrading/#requirements","text":"A Pitaya-Link Debug Probe macOS, Linux, or Windows 7 or newer 1x USB-C Cable","title":"Requirements"},{"location":"upgrading/#prepare-the-firmware","text":"The current release DAPLink firmware is hosted on GitHub Release Site with the name pitaya_link_ target _if_crc_ version .bin . Download","title":"Prepare the firmware"},{"location":"upgrading/#update-the-firmware","text":"To update the firmware, follow these steps: Enter DFU mode by pressing DFU/RESET button during power up. The board should mount as a disk drive called CRP DISABLD . Open CRP DISABLD , and remove the file called firmware.bin . Copy the new firmware ( .bin -format file prepared above) onto CRP DISABLD : On Windows, replace firmware.bin with the new firmware. On Linux/macOS, use dd command: dd if ={ new_firmware.bin } of ={ firmware.bin } conv = notrunc Unplug your Pitaya-Link, and plug it back in. It should now appear as a disk drive called PITAYA-LINK .","title":"Update the firmware"},{"location":"upgrading/#verify-the-update","text":"Check the DETAILS.TXT file in PITAYA-LINK to verify the Interface Version .","title":"Verify the update"},{"location":"upgrading/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"vscode/","text":"Using Pitaya-Link with Visual Studio Code Introduction This guide explains how to configure the local debug toolchain using Pitaya-Link with Visual Studio Code. Requirements A Pitaya-Link Debug Probe Visual Studio Code An nRF52 target board (e.g. nRF52840 MDK USB Dongle ) Install Visual Studio Code You need to install Visual Studio Code with the C/C++ extensions to begin. Install Visual Studio Code . Open Visual Studio Code, and click on the Extensions button. Search for the C/C++ plugin (by Microsoft) and click Install . When prompted, restart the IDE. Install pyOCD The latest stable version of pyOCD may be installed via pip as follows. Skip this step if pyOCD already exists. pip install -U pyocd Install GNU Arm Embedded Toolchain Download and install the GNU ARM Embedded Toolchain . Then ensure the path is added to your OS PATH environment variable: # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if arm-none-eabi-gcc works: arm-none-eabi-gcc --version Configuring the debugger The launch.json file is used to configure the debugger in Visual Studio Code. Perform the following steps to configure the debugger for your project: Open the project folder in Visual Studio Code. Open the .vscode/launch.json file and add the example configurations: { version : 0.2.0 , configurations : [ { name : C++ Launch , type : cppdbg , request : launch , program : ${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out , args : [], stopAtEntry : true , cwd : ${workspaceRoot} , environment : [], externalConsole : false , debugServerArgs : , serverLaunchTimeout : 20000 , filterStderr : true , filterStdout : false , serverStarted : GDB\\\\ server\\\\ started , preLaunchTask : make , setupCommands : [ { text : -target-select remote localhost:3333 , description : connect to target , ignoreFailures : false }, { text : -file-exec-and-symbols ${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out , description : load file , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor endian little\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor reset\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor halt\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor arm semihosting enable\\ , ignoreFailures : false }, { text : -target-download , description : flash target , ignoreFailures : false } ], logging : { moduleLoad : true , trace : true , engineLogging : true , programOutput : true , exceptions : true }, linux : { MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb , debugServerPath : pyocd-gdbserver }, osx : { MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb , debugServerPath : pyocd-gdbserver }, windows : { preLaunchTask : make.exe , MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb.exe , debugServerPath : pyocd-gdbserver.exe , setupCommands : [ { text : -environment-cd ${workspaceRoot}\\\\armgcc\\\\_build }, { text : -target-select remote localhost:3333 , description : connect to target , ignoreFailures : false }, { text : -file-exec-and-symbols nrf52840_xxaa.out , description : load file , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor endian little\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor reset\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor halt\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor arm semihosting enable\\ , ignoreFailures : false }, { text : -target-download , description : flash target , ignoreFailures : false } ] } } ] } Create a make task in .vscode/tasks.json file: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : make , options : { cwd : ${workspaceRoot}/armgcc }, problemMatcher : { owner : cpp , fileLocation : [ relative , ${workspaceRoot} ], pattern : { regexp : ^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$ , file : 1 , line : 2 , column : 3 , severity : 4 , message : 5 } }, args : [], linux : { command : make }, osx : { command : make }, windows : { command : make.exe } } ] } Connecting the target Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable. Debugging your project Click the menu Debug - Start Debugging , and debugging starts. Click on the DEBUG CONSOLE tab to see the debug output: Now you can explore the debugging capabilities for Variables, Breakpoints and more. Example Sources The example project files we are using in this guide are located in GitHub: View Sources Reference VS Code Launch Json Reference VS Code Tasks Documentation Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Usage with Visual Studio Code"},{"location":"vscode/#using-pitaya-link-with-visual-studio-code","text":"","title":"Using Pitaya-Link with Visual Studio Code"},{"location":"vscode/#introduction","text":"This guide explains how to configure the local debug toolchain using Pitaya-Link with Visual Studio Code.","title":"Introduction"},{"location":"vscode/#requirements","text":"A Pitaya-Link Debug Probe Visual Studio Code An nRF52 target board (e.g. nRF52840 MDK USB Dongle )","title":"Requirements"},{"location":"vscode/#install-visual-studio-code","text":"You need to install Visual Studio Code with the C/C++ extensions to begin. Install Visual Studio Code . Open Visual Studio Code, and click on the Extensions button. Search for the C/C++ plugin (by Microsoft) and click Install . When prompted, restart the IDE.","title":"Install Visual Studio Code"},{"location":"vscode/#install-pyocd","text":"The latest stable version of pyOCD may be installed via pip as follows. Skip this step if pyOCD already exists. pip install -U pyocd","title":"Install pyOCD"},{"location":"vscode/#install-gnu-arm-embedded-toolchain","text":"Download and install the GNU ARM Embedded Toolchain . Then ensure the path is added to your OS PATH environment variable: # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if arm-none-eabi-gcc works: arm-none-eabi-gcc --version","title":"Install GNU Arm Embedded Toolchain"},{"location":"vscode/#configuring-the-debugger","text":"The launch.json file is used to configure the debugger in Visual Studio Code. Perform the following steps to configure the debugger for your project: Open the project folder in Visual Studio Code. Open the .vscode/launch.json file and add the example configurations: { version : 0.2.0 , configurations : [ { name : C++ Launch , type : cppdbg , request : launch , program : ${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out , args : [], stopAtEntry : true , cwd : ${workspaceRoot} , environment : [], externalConsole : false , debugServerArgs : , serverLaunchTimeout : 20000 , filterStderr : true , filterStdout : false , serverStarted : GDB\\\\ server\\\\ started , preLaunchTask : make , setupCommands : [ { text : -target-select remote localhost:3333 , description : connect to target , ignoreFailures : false }, { text : -file-exec-and-symbols ${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out , description : load file , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor endian little\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor reset\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor halt\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor arm semihosting enable\\ , ignoreFailures : false }, { text : -target-download , description : flash target , ignoreFailures : false } ], logging : { moduleLoad : true , trace : true , engineLogging : true , programOutput : true , exceptions : true }, linux : { MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb , debugServerPath : pyocd-gdbserver }, osx : { MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb , debugServerPath : pyocd-gdbserver }, windows : { preLaunchTask : make.exe , MIMode : gdb , MIDebuggerPath : arm-none-eabi-gdb.exe , debugServerPath : pyocd-gdbserver.exe , setupCommands : [ { text : -environment-cd ${workspaceRoot}\\\\armgcc\\\\_build }, { text : -target-select remote localhost:3333 , description : connect to target , ignoreFailures : false }, { text : -file-exec-and-symbols nrf52840_xxaa.out , description : load file , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor endian little\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor reset\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor halt\\ , ignoreFailures : false }, { text : -interpreter-exec console \\ monitor arm semihosting enable\\ , ignoreFailures : false }, { text : -target-download , description : flash target , ignoreFailures : false } ] } } ] } Create a make task in .vscode/tasks.json file: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format version : 2.0.0 , tasks : [ { label : make , options : { cwd : ${workspaceRoot}/armgcc }, problemMatcher : { owner : cpp , fileLocation : [ relative , ${workspaceRoot} ], pattern : { regexp : ^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$ , file : 1 , line : 2 , column : 3 , severity : 4 , message : 5 } }, args : [], linux : { command : make }, osx : { command : make }, windows : { command : make.exe } } ] }","title":"Configuring the debugger"},{"location":"vscode/#connecting-the-target","text":"Perform the following steps to connect the target board: Connect the target board to Pitaya-Link using the provided 7-pin Cable. Connect Pitaya-Link to the PC using the provided USB-C Cable.","title":"Connecting the target"},{"location":"vscode/#debugging-your-project","text":"Click the menu Debug - Start Debugging , and debugging starts. Click on the DEBUG CONSOLE tab to see the debug output: Now you can explore the debugging capabilities for Variables, Breakpoints and more.","title":"Debugging your project"},{"location":"vscode/#example-sources","text":"The example project files we are using in this guide are located in GitHub: View Sources","title":"Example Sources"},{"location":"vscode/#reference","text":"VS Code Launch Json Reference VS Code Tasks Documentation","title":"Reference"},{"location":"vscode/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"where-to-buy/","text":"Where to Buy Pitaya-Link Buy Online Pitaya-Link is available on the following channels (click to go directly to the product): Bulk Customization We are ready to customize our electronics and firmware to better meet your solution's needs. Many of our platforms are prepared for customization. If you would like to do some serious business, drop a line and we'll reply before you know it. Email Us","title":"Where to Buy"},{"location":"where-to-buy/#where-to-buy-pitaya-link","text":"","title":"Where to Buy Pitaya-Link"},{"location":"where-to-buy/#buy-online","text":"Pitaya-Link is available on the following channels (click to go directly to the product):","title":"Buy Online"},{"location":"where-to-buy/#bulk-customization","text":"We are ready to customize our electronics and firmware to better meet your solution's needs. Many of our platforms are prepared for customization. If you would like to do some serious business, drop a line and we'll reply before you know it. Email Us","title":"Bulk &amp; Customization"}]}